Ask about the planning when to hand it in etc


about the code:

- I would expect the list in the heap constructor to look like List (HeapNodeAux α (HeapNodeAux α))
or something because the children are heapnodes as well.
- I saw somewhere that a single node has rank 0 but in the singleton function it is given 1 
- the le function that is an argument to the functions, is that because the values can be different types?
- In the combine function does the n2.children ++ [heap[n1]] just add n1 as a child, if so, why is it necessary to have heap in front of n1.
- also what does partial in front of def mean?
- what does |> do?
- does the head? function return the lowest value in the heap?(same as findMin ?) and what does the other head function do
- In the deletemin function does the foldl function just loop over the elements in hs and then merges them?
- what does some do in the deletemin
- in toArray is go just a function inside the function because we can't call toArray recursively because we have to store the array?
- the unorderd version of toArray and list have some notation id don't know 

about the book:
- Don't understand what (motive := fun _ => Nat) does in casesOn  
- In the book it is asked to show that bool and nat are inhabited but before that it says that inhabited is just a witness that an element exists so would have no idea how to do that
-trouble understanding @-notation with implicit arguments(about halfway through chapter6)
-also trouble understanding the  Σ notation
-don't really understand how the .rec function on inductive types is used
-still find it hard to see when you should use what approach to a proof(ex: sometimes a whole proof can be done with only rfl but sometimes when both sides are also equal rfl alone isn't enough,
how should in chapter 7 append list be proved)
-with the induction tactics they mention the premises which I dont't really understand and in particular the induction tactic with "multiple targets"
-could you explain the welfounded recursion if it is necessary
- Is there a way to easily see when to use classical reasoning
- how to start non propositional proofs such as the append_nil theorem(vsc)

Exercises:
- (∃ x, p x) ↔ ¬ (∀ x, ¬ p x): I find it difficult to see what you should do when proofing (∃ x, p x) <- ¬ (∀ x, ¬ p x) because of the negation.


New questions:
- the book you gave and a comment in the implementation mention that parentnode needs to have greater value than its children but I think it's implemented the other way around.
- the first constructor in P shouldn't that be rank 1 because there is no way a bin tree can be constructed with rank 0
- Is the notation IsBinTree <val, rank, children> the same as IsBinTree a?
- how does the syntax work because we can name the arguments for example we can name the list (heapnodes a) but then we cant use the :: notation to get the head of the list as we do with pattern matching 
- should the < be le as an argument to the inductive type 
- Where should my code be written should I open binomialheapimp namespace?




New questions:
- I know what the constructor does but I forgot how you could actually apply a specific constructor
- About the induction in combination with the generalizing


-make issue file in lean 4 github page with the bintree the new theorem and the merge function(should be minimal working example)
- fill in sorry for the merge proofs so i can use them for findmin and deletemin



-in the comment above the BinTree abbrev I think they made a mistake because this comment implicates that the heaps don't follow the minimal heap rule while I think this is implemented.